<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2022/01/22/test/"/>
    <url>/2022/01/22/test/</url>
    
    <content type="html"><![CDATA[<p>This is a test.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>csapp作业二</title>
    <link href="/2021/12/11/csapp%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2021/12/11/csapp%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><h2 id="3-58"><a href="#3-58" class="headerlink" title="3.58"></a>3.58</h2><p><strong>题目描述</strong></p><p>​    一个函数的原型为 <code>long decode2(long x, long y, long z);</code></p><p>​    <code>GCC</code>产生如下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">decode2:<br>subq%rdx, %rsi<br>imulq%rsi, %rdi<br>movq%rsi, %rax<br>salq$63, %rax<br>sarq$63, %rax<br>xorq%rdi, %rax<br>ret<br></code></pre></td></tr></table></figure><p>参数<code>x</code>、<code>y</code>和<code>z</code>通过寄存器<code>%rdi</code>、<code>%rsi</code>和<code>%rdx</code>传递。代码将返回值存放在寄存器<code>%rax</code>中。</p><p>写出等价于上述汇编代码的<code>decode2</code>的<code>C</code>代码。</p><p><strong>解答程序如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">decode2</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y, <span class="hljs-keyword">long</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    y = y - z;<br>    x = x * y;<br>    y = y &lt;&lt; <span class="hljs-number">63</span>;<br>    y = y &gt;&gt; <span class="hljs-number">63</span>;<br>    y= y ^ x;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-60"><a href="#3-60" class="headerlink" title="3.60"></a>3.60</h2><p><strong>题目描述：</strong></p><p>​    考虑下面的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">long loop(long x,int n)<br>x in %rdi, n in %esi<br>loop:<br>movl%esi, %ecx<br>movl$1,%edx<br>movl$0,%eax<br>jmp.L2<br>.L3:<br>movq%rdi, %r8<br>andq%rdx, %r8<br>orq%r8, %rax<br>salq%cl, %rdx<br>.L2:<br>testq%rdx, %rdx<br>jne.L3<br>rep; ret<br></code></pre></td></tr></table></figure><p>​    以上代码是编译以下整体形式的<code>C</code>代码产生的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">loop</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> result = ____0_____;<br>    <span class="hljs-keyword">long</span> mask;<br>    <span class="hljs-keyword">for</span> (mask = ___1___; mask ___！= <span class="hljs-number">0</span> ____ ; mask = __mask &lt;&lt; (n &amp; <span class="hljs-number">0xff</span>)__ )&#123;<br>        result |= __(x&amp;mask)__;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    你的任务是填写这个<code>C</code>代码中缺失的部分，得到一个程序等价于产生的汇编代码。回想一下，这个函数的结果是在寄存器<code>%rax</code>中返回的。你会发现以下工作很有帮助：检查循环之前、之中和之后的汇编代码，形成一个寄存器和程序变量之间一致的映射。</p><p>​    A. 哪个寄存器保存着程序值<code>x</code>、<code>n</code>、<code>result</code>和<code>mask</code>？</p><p>​    B. <code>result</code>和<code>mask</code>的初始值是什么？</p><p>​    C. <code>mask</code>的测试条件是什么？</p><p>​    D. <code>mask</code>是如何被修改的？</p><p>​    E. <code>result</code>是如何被修改的？</p><p>​    F. 填写这段<code>C</code>代码中所有缺失的部分。</p><p><strong>解答：</strong></p><p>​    <code>A</code>：<code>%r8</code>保存着<code>x</code>，<code>%ecx</code>保存着<code>n</code>，<code>%rax</code>保存着<code>result</code>，<code>%rdx</code>保存着<code>mask</code>。</p><p>​    <code>B</code>：<code>result</code>的初始值为<code>0</code>，<code>mask</code>的初始值为<code>1</code></p><p>​    <code>C</code>：根据<code>.L2</code>中<code>testq %rdx, %rdx</code>指令可以看出，<code>mask</code>的测试条件是<code>mask</code>是否等于<code>0</code>，如果等于<code>0</code>则返回，否则继续循环。</p><p>​    <code>D</code>：根据指令<code>salq %cl,%rdx</code>可知，<code>mask</code>每次循环需要进行左移操作，左移位数为<code>%cl</code>中的值，由于<code>%ecx</code>中存储着<code>n</code>的值，但是<code>%cl</code>为<code>n</code>的低<code>8</code>位，所以最终<code>mask=mask &lt;&lt; (n &amp; 0xff)</code>。</p><p>​    <code>E</code>：根据<code>.L3</code>中前三条指令可以看出，<code>result=(x&amp;mask)|result</code></p><p>​    <code>F</code>：完整程序如上。</p><h2 id="3-63"><a href="#3-63" class="headerlink" title="3.63"></a>3.63</h2><p><strong>题目描述：</strong></p><p>​    这个程序给你一个机会，从反汇编机器代码逆向工程一个<code>switch</code>语句。在下面这个过程中，去掉了<code>switch</code>语句的主体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">switch_prob</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">long</span> result = x;<br>    <span class="hljs-keyword">switch</span>(n)&#123;<br>         <span class="hljs-comment">/* Fill in code here */</span><br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    反汇编机器代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">long switch_prob(long x, long n)<br>x in %rdi, n in %rsi<br>0000000000400590 &lt;switch_prob&gt;:<br>400590:48 83 ee 3csub    &amp;0x3c, %rsi<br>400594:48 83 fe 05cmp   $0x5, %rsi<br>400598: 77 29    ja   4005c3 &lt;switch_prob+0x33&gt;<br>40059a: ff 24 f5 f8 06 40 00 jmpq*0x4006f8(, %rsi, 8)<br>4005a1: 48 8d 04 fd 00 00 00 lea0x0(, %rdi, 8), %rax<br>4005a8: 00<br>4005a9: c3    retq<br>4005aa: 48 89 f8mov    %rdi, %rax<br>4005ad: 48 c1 f8 03sar   $0x3, %rax<br>4005b1: c3    retq<br>4005b2: 48 89 f8mov   %rdi, %rax<br>4005b5: 48 c1 e0 04shl   $0x4, %rax<br>4005b9: 48 29 f8sub   %rdi, %rax<br>4005bc: 48 89 c7mov    %rax, %rdi<br>4005bf: 48 0f af ffimul   %rdi, %rdi<br>4005c3: 48 8d 47 4blea    0x4b(%rdi), %rax<br>4005c7: c3   retq<br></code></pre></td></tr></table></figure><p>​    跳转表驻留在内存的不同区域中。可以从第5行的间接跳转看出来，跳转表的起始地址为<code>0x4006f8</code>。用调试器<code>GDB</code>，我们可以用命令<code>x/6gx 0x4006f8</code>来检查组成跳转表的6个8字节字的内存。<code>GDB</code>打印出下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb)x/6gx 0x4006f8<br>0x4006f8:0x00000000004005a10x00000000004005c3<br>0x400708:0x00000000004005a10x00000000004005aa<br>0x400718:0x00000000004005b20x00000000004005bf<br></code></pre></td></tr></table></figure><p>​    用<code>C</code>代码填写开关语句的主体，使它的行为与机器代码一致。</p><p><strong>解答：</strong></p><p>​    首先由反汇编代码前两行可以看出，<code>n</code>需要减去<code>60</code>，且<code>case</code>的情况只有5种，所以<code>case</code>中取值范围是<code>60~65</code>；接下来看跳转表中内容，分别对应6种情况与跳转地址。通过地址比对可以写出如下程序。</p><p><strong>程序如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">switch_prob</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">long</span> result = x;<br>    <span class="hljs-keyword">switch</span>(n)&#123;<br>         <span class="hljs-comment">/* Fill in code here */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>：<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-comment">//case 60、62执行相同功能，case 61执行default，因此可以合并</span><br>            <span class="hljs-keyword">return</span> x * <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">63</span>:<br>            <span class="hljs-keyword">return</span> x &gt;&gt; <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>:<br>            x = x &lt;&lt; <span class="hljs-number">4</span> - x;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>:<br>            x= x * x;<br>        <span class="hljs-keyword">default</span>:<br>            result = x + <span class="hljs-number">75</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-69"><a href="#3-69" class="headerlink" title="3.69"></a>3.69</h2><p><strong>题目描述：</strong></p><p>​    你负责维护一个大型的<code>C</code>程序，遇到下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> first;<br>    a_struct a[CNT];<br>    <span class="hljs-keyword">int</span> last;<br>&#125; b_struct;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i, b_struct *bp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = bp-&gt;first + bp-&gt;last;<br>    a_struct *ap = &amp;bp-&gt;a[i];<br>    ap-&gt;x[ap-&gt;idx] = n;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    编译时常数<code>CNT</code>和结构<code>a_struct</code>的声明是在一个你没有访问权限的文件中。幸好，你有代码的<code>.o</code>版本，可以用<code>OBJDUMP</code>程序来反汇编这些文件，得到下面的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">void test(long i, b_struct *bp)<br>i in %rdi, bp in %rsi<br>0000000000000000 &lt;test&gt;:<br>10:8b 8e 20 01 00 00mov0x120(%rsi), %ecx<br>26:03 0e   add    (%rsi), %ecx<br>38:48 8d 04 bf    lea(%rdi,%rdi,4), %rax<br>4c:48 8d 04 c6    lea(%rsi, %rax,8), %rax<br>510:48 8b 50 08mov0x8(%rax), %rdx<br>614:48 63 c9movslq%ecx, %rcx<br>717:48 89 4c d0 10mov%rcx, 0x10(%rax,%rdx,8) <br>81c:c3   retq<br></code></pre></td></tr></table></figure><p>​    运用你的逆向工程技术，推断出下列内容：</p><p>​    A. <code>CNT</code>的值</p><p>​    B. 结构<code>a_struct</code>的完整声明。假设这个结构中只有字段<code>idx</code>和<code>x</code>，并且这两个字段保存的都是有符号值。</p><p><strong>解答：</strong></p><p>​    首先反汇编代码前两行表示<code>bp-&gt;first+bp-&gt;last</code>，由于这两个元素在<code>b_struct</code>中分别位于首尾两端，所以可知<code>b_struct</code>的大小是<code>288B</code>；代码中3、4两行可以得到<code>%rax</code>保存着值为<code>bp+40*i</code>，<code>%rdx</code>中保存值为<code>bp+40*i+8</code>，也就是最后指针<code>ap</code>的值，可以看出<code>a_struct</code>的大小是<code>40B</code>，但<code>b_struct</code>第一个元素是一个<code>int</code>型数据，大小是<code>4B</code>，但<code>%rdx</code>中偏移量是<code>8</code>，所以按照内存对齐原则猜测结构<code>a_struct</code>中的最大元素是<code>8B</code>，同时<code>movslq %ecx, %rcx</code>这条指令将<code>n</code>从双字符号拓展至四字，最后存入<code>ap-&gt;x[ap-&gt;idx]</code>中，也可以看出<code>a_struct</code>中<code>x</code>的大小是<code>8B</code>，所以<code>x</code>的类型是<code>long</code>。</p><p>​    所以<code>CNT</code>的大小是<code>(288-8)/40=7</code>，<code>b_struct</code>的大小减去首尾<code>int</code>对齐的两个<code>8B</code>。汇编代码第7行对应<code>ap-&gt;x[ap-&gt;idx] = n</code>，即<code>n</code>要保存到地址为<code>ap+sizeof(idx)+8*idx</code>的位置，接下来分析<code>mov %rcx, 0x10(%rax,%rdx,8)</code>这条指令，先理清<code>%rax</code>和<code>%rdx</code>中的值：</p><p>​    <code>%rax=bp+40*i</code>，<code>%rdx=M[bp+40*i+8]</code>，<code>0x10(%rax,%rdx,8)=bp+40*i+8+8+8*M[bp+40*i+8]</code>，这里有个细节我一直没注意到，所以这题写了很久，原来<code>lea</code>指令是将一个寄存器中的值移到另一个寄存器中，而<code>mov</code>指令才用到了偏移寻址，将以寄存器值为地址对应的数存入了<code>%rdx</code>中（我一直把<code>mov</code>当成<code>lea</code>使用了），所以<code>%rax</code>存的是地址，<code>%rdx</code>存的是操作数。</p><p>​    这样结构<code>a_struct</code>的布局就很明显了，<code>idx</code>为<code>long</code>，<code>x</code>是一个<code>long</code>类型的数组，由于<code>a_struct</code>的大小是<code>40B</code>，所以<code>x</code>大小是<code>32B</code>，共<code>4</code>个元素。</p><p>​    最后，两个结构体声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> first;<br>    a_struct a[<span class="hljs-number">7</span>];<br>    <span class="hljs-keyword">int</span> last;<br>&#125; b_struct;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">long</span> idx;<br>    <span class="hljs-keyword">long</span> x[<span class="hljs-number">4</span>];<br>&#125; a_struct;<br></code></pre></td></tr></table></figure><h2 id="3-70"><a href="#3-70" class="headerlink" title="3.70"></a>3.70</h2><p><strong>题目描述：</strong></p><p>​    考虑下面的联合声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">ele</span> &#123;</span><br><span class="hljs-number">2</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-number">3</span>            <span class="hljs-keyword">long</span> *p;<br><span class="hljs-number">4</span>            <span class="hljs-keyword">long</span> y;<br><span class="hljs-number">5</span>        &#125; e1;<br><span class="hljs-number">6</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-number">7</span>        <span class="hljs-keyword">long</span> x;<br><span class="hljs-number">8</span>            <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">ele</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-number">9</span>    &#125; e2;<br><span class="hljs-number">10</span>&#125;;<br></code></pre></td></tr></table></figure><p>​    这个声明说明联合中可以嵌套结构。</p><p>​        下面的函数（省略了一些表达式）对一个链表进行操作，链表是以上联合作为元素的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proc</span> <span class="hljs-params">(<span class="hljs-keyword">union</span> ele *up)</span> </span>&#123;<br><span class="hljs-number">2</span>up-&gt;_______ = *(_______) - ________;    <br>&#125;<br></code></pre></td></tr></table></figure><p>​    A. 下列字段的偏移量是多少（以字节为单位）：</p><p>​            <code>e1.p</code>             <strong><strong>___</strong></strong></p><p>​            <code>e1.y</code>           <strong><strong>___</strong></strong></p><p>​            <code>e2.x</code>            <strong>____</strong></p><p>​            <code>e2.next</code>     <strong><strong>___</strong></strong></p><p>​    B. 这个结构总共需要多少个字节？</p><p>​    C. 编译器为<code>proc</code>产生下面的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">void proc (union ele *up)<br>up in %rdi<br>1proc:<br>2movq8(%rdi), %rax<br>3movq(%rax), %rdx<br>4movq(%rdx), %rdx<br>5subq8(%rax), %rdx<br>6movq%rdx, (%rdi)<br>7ret<br></code></pre></td></tr></table></figure><p><strong>解答：</strong></p><p>​    <code>union</code>中各对象共享内存，<code>e1</code>中有两个8字节的数据，<code>e2</code>中也有两个8字节的数据，所以<code>union</code>共16个字节，<code>e1</code>和<code>e2</code>共用内存</p><p>​    A.     <code>e1.p</code>             0</p><p>​            <code>e1.y</code>             8</p><p>​            <code>e2.x</code>             0</p><p>​            <code>e2.next</code>        8</p><p>B.  共16字节</p><p>C. </p><p>​        汇编代码第2行执行后，<code>%rax</code>中保存着是<code>*(up+8)</code>，即<code>e1.y</code>或<code>e2.next</code>；第3行执行完后，<code>%rdx</code>中存着<code>*(*(up+8))</code>，所以<code>%rax</code>中保存的只能是一个指针<code>e2.next</code>，执行完第4行指令后，<code>%rdx</code>中存着<code>*(up-&gt;(e2.next)-&gt;e1.p)</code>，此时<code>%rdx</code>中是一个<code>long</code>型数据，所以第5行指令中<code>8(%rax)</code>也必须是一个<code>long</code>型数据，即<code>8(%rax)</code>表示<code>(up-&gt;(e2.next))-&gt;e1.y</code>；最后将<code>%rdx</code>移动到<code>%rdi</code>所指内存中，对应着源代码的赋值语句。</p><p>​        综上，可填出以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proc</span> <span class="hljs-params">(<span class="hljs-keyword">union</span> ele *up)</span> </span>&#123;<br><span class="hljs-number">2</span>up-&gt;__e2.x___ = *(__(up-&gt;e2.next)-&gt;e1.p__) - __(up-&gt;e2.next)-&gt;e1.y__;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP作业一</title>
    <link href="/2021/12/05/csapp%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2021/12/05/csapp%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h1><h2 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h2><p><strong>题目描述：</strong></p><p>​    编写过程  <code>is_little_endian</code>，当在小端法机器上编译和运行时返回1，在大端法机器上编译运行时则返回0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。</p><p><strong>解答：</strong></p><p>​    可以设置一个 <code>int</code> 型数据为 <code>0xff</code> ，通过判断低一个字节的数据是否为 <code>0xff</code> 来判断该机器是否使用小端法，如果是小端存储，则低字节数据是 <code>0xff</code>，否则是 <code>0x00</code> 。</p><p><strong>程序如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_little_endian</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> num=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* test_num=(unsignen <span class="hljs-keyword">char</span>*) &amp;num;<br>    <span class="hljs-keyword">if</span>(test_num[<span class="hljs-number">0</span>]==oxff)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-61"><a href="#2-61" class="headerlink" title="2.61"></a>2.61</h2><p><strong>题目描述：</strong></p><p>​    写一个<code>C</code>表达式，在下列描述的条件下产生<code>1</code>，而在其他情况下得到<code>0</code>。假设<code>x</code>是<code>int</code>类型。</p><p>​    A. <code>x</code>的任何位都等于<code>1</code>。</p><p>​    B. <code>x</code>的任何位都等于<code>0</code>。</p><p>​    C. <code>x</code>的最低有效字节中的位都等于<code>1</code>。</p><p>​    D. <code>x</code>的最高有效字节中的位都等于<code>0</code>。</p><p>​    代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（ == ）和不相等（ != ）测试。</p><p><strong>解答程序如下：</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">condition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> MSB = <span class="hljs-number">0xff000000</span>; <span class="hljs-comment">//高字节</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> LSB = <span class="hljs-number">0xff</span>;  <span class="hljs-comment">//低字节</span><br>    <span class="hljs-comment">//如果x是全1，则按位取反后为全0，再取非操作一定为1</span><br>    <span class="hljs-comment">//如果x是全0，则对其进行逻辑非操作一定为1</span><br>    <span class="hljs-keyword">if</span> (!(~x) || !x) &#123; <span class="hljs-comment">//条件A和B</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//x&amp;LSB表示取低字节有效部分，再对其与LSB按位异或，相同返回0，不同返回1</span><br>    <span class="hljs-comment">//x&amp;MSB表示取高字节有效部分，再对其与MSB按位与，如最高有效字节都等于0，则返回0，否则返回非0</span><br>    <span class="hljs-keyword">if</span> (!((x &amp; LSB) ^ LSB) || !((x &amp; MSB) &amp; MSB)) &#123; <span class="hljs-comment">//条件C和D</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-77"><a href="#2-77" class="headerlink" title="2.77"></a>2.77</h2><p><strong>题目描述：</strong></p><p>​    假设我们有一个任务：生成一段代码，将整数变量 <code>x</code> 乘以不同的常数因子 <code>K</code> 。为了提高效率，我们想只使用 <code>+、-</code> 和 <code>&lt;&lt;</code> 运算。对于下列 <code>K</code> 的值，写出执行乘法运算的 <code>C</code> 表达式，每个表达式中最多使用<code>3</code>个运算。</p><p>​    A. $K = 17$</p><p>​    B. $K = -7$</p><p>​    C. $K = 60$</p><p>​    D. $K = -112$</p><p><strong>解答：</strong></p><p>​    这里假设所有乘法都不会溢出</p><ol><li><p>$K=17$，可以拆成<code>16+1</code> ，即 ：</p><p>​                                                </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(x &lt;&lt; <span class="hljs-number">4</span>) + x<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>$K=-7$，可以拆成 <code>1-8</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x - (x &lt;&lt; <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>$K=60$ ，可以拆成<code>32+16+8+4</code> ，即 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(x &lt;&lt; <span class="hljs-number">5</span>) + (x &lt;&lt; <span class="hljs-number">4</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>$K=-112$ ，可以拆成 <code>16-128</code>，再取相反数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(x &lt;&lt; <span class="hljs-number">4</span>) - (x &lt;&lt; <span class="hljs-number">7</span>) <br></code></pre></td></tr></table></figure></li></ol><h2 id="2-84"><a href="#2-84" class="headerlink" title="2.84"></a>2.84</h2><p><strong>题目描述：</strong></p><p>​    填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数 <code>f2u</code> 返回一个无符号 <code>32</code> 位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是 <code>NaN</code>。两种<code>0</code> ,<code>+0</code>和<code>-0</code>被认为是相等的。</p><p><strong>解答：</strong></p><p>​    如果 <code>x</code> 和 <code>y</code> 符号分别为<code>0</code>和<code>1</code>或 <code>x=y=0</code>则说明<code>x&lt;=y</code>，可直接返回<code>1</code>；如果<code>x</code>和<code>y</code>符号相同，根据<code>IEEE754</code>浮点数的标准，可以直接通过其<code>unsigned</code>类型的值来判断大小，再由符号决定判断结果。</p><p><strong>程序如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">float_le</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> ux = f2u(x);<br>    <span class="hljs-keyword">unsigned</span> uy = f2u(y);<br><br>    <span class="hljs-comment">/* Get the sign bits */</span><br>    <span class="hljs-keyword">unsigned</span> sx = ux &gt;&gt; <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">unsigned</span> sy = uy &gt;&gt; <span class="hljs-number">31</span>;<br><br>    <span class="hljs-comment">/* Give an expression using only ux,uy,sx,and sy */</span><br>    <span class="hljs-comment">//如果x是正数，y是负数，或者x=y=0，则x&gt;=y</span><br>    <span class="hljs-keyword">if</span> ((sx == <span class="hljs-number">0</span> &amp;&amp; sy == <span class="hljs-number">1</span>) || ((ux &lt;&lt; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &amp;&amp; (uy &lt;&lt; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果x是负数，y是正数，则x&lt;y</span><br>    <span class="hljs-keyword">if</span> (sx == <span class="hljs-number">1</span> &amp;&amp; sy == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果x和y都是正数，可直接判断，绝对值大的数大</span><br>    <span class="hljs-keyword">if</span> (sx == <span class="hljs-number">0</span> &amp;&amp; sy == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ux &gt;= uy;<br>    &#125;<br>    <span class="hljs-comment">//如果x和y都是负数，可直接判断，绝对值大的数小</span><br>    <span class="hljs-keyword">return</span> ux &lt;= uy;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-89"><a href="#2-89" class="headerlink" title="2.89"></a>2.89</h2><p><strong>题目描述：</strong></p><p>​    我们在一个<code>int</code>类型为<code>32</code>位补码表示的机器上运行程序。<code>float</code>类型的值使用<code>32</code>位<code>IEEE</code>格式，而<code>double</code>类型的值使用<code>64</code>位<code>IEEE</code>格式。</p><p>​    我们产生随机整数<code>x</code>、<code>y</code>和<code>z</code>，并且把它们转换成<code>double</code>类型的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create some arbitrary values */</span><br><span class="hljs-keyword">int</span> x = random();<br><span class="hljs-keyword">int</span> y = random();<br><span class="hljs-keyword">int</span> z = random();<br><span class="hljs-comment">/* Convert to double */</span><br><span class="hljs-keyword">double</span> dx = (<span class="hljs-keyword">double</span>) x;<br><span class="hljs-keyword">double</span> dy = (<span class="hljs-keyword">double</span>) y;<br><span class="hljs-keyword">double</span> dz = (<span class="hljs-keyword">double</span>) z;<br></code></pre></td></tr></table></figure><p>​    对于下列的每个<code>C</code>表达式，你要指出表达式是否总是为<code>1</code>。如果它总是为<code>1</code>，描述其中的数学原理。否则，列举出使它为<code>0</code>的参数的例子。请注意，不能使用<code>IA32</code>机器运行<code>GCC</code>来测试你的答案，因为对于<code>float</code>和<code>double</code>，它使用的都是<code>80</code>位的拓展精度表示。</p><p>​    <code>A. (float)x==(float)dx</code></p><p>​    <code>B. dx-dy==(double)(x-y)</code></p><p>​    <code>C. (dx+dy)+dz==dx+(dy+dz)</code></p><p>​    <code>D. (dx*dy)*dz==dx*(dy*dz)</code></p><p>​    <code>E. dx/dx==dz/dz</code></p><p><strong>解答：</strong></p><p>​    1、<code>A. (float)x==(float)dx</code>。正确，因为<code>int</code>转换为<code>double</code>不会损失精度，因此<code>x</code>和<code>dx</code>都相同，再转换为<code>float</code>也会相同。</p><p>​    2、<code>B. dx-dy==(double)(x-y)</code>。如果<code>x=0x80000000</code>,<code>y=-1</code>，此时<code>(x-y)</code>会溢出，但由于<code>dx</code>和<code>dy</code>可表示范围大，相减能够得到正确答案，而<code>(x-y)=0x7fffffff</code>，转化为<code>double</code>会变为一个正数，所以表达式不总成立。</p><p>​    3、<code>C. (dx+dy)+dz==dx+(dy+dz)</code>。正确，因为该表达式变量都是相同类型，相加满足交换率。</p><p>​    4、<code>D. (dx*dy)*dz==dx*(dy*dz)</code>。如果<code>dx*dy=C</code>，而<code>dy*dz=无穷</code>，则表达式不成立。</p><p>​    5、<code>E. dx/dx==dz/dz</code>。如果<code>dx=1.0,dz=0.0</code>则表达式不成立了。</p><h2 id="2-91"><a href="#2-91" class="headerlink" title="2.91"></a>2.91</h2><p><strong>题目描述：</strong></p><p>​    大约在公元前<code>250</code>年，希腊数学家阿基米德证明了$\frac{223}{71}&lt;\pi&lt;\frac{22}{7}$。如果当时有一台计算机和标准库<code>&lt;math.h&gt;</code>，他就能确定 $\pi$ 的单精度浮点近似值的十六进制 表示为<code>0x40490FDB</code>。当然，所有的这些都只是近似值，因为 $\pi$ 不是有理数。</p><p>​    A. 这个浮点值表示的二进制小数是多少？</p><p>​    B. $\frac{22}{7}$ 的二进制小数表示是什么？</p><p>​    C. 这两个 $\pi$ 的近似值从哪一位（相对于二进制小数点）开始不同的？</p><p><strong>解答：</strong></p><p>​    A. 二进制小数是：<code>0 10000000 10010010000111111011011</code>，即<code>11.0010010000111111011011</code>(二进制)</p><p>​    B. $\frac{1}{7}$ 用二进制表示为 <code>0.001001001...</code>，所以$\frac{22}{7}=3+\frac{1}{7}$ ，用二进制小数表示为 <code>11.001001001...</code></p><p>​    C. 两个 $\pi$ 近似值从第<code>9</code>位开始不同的。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Network Technology</title>
    <link href="/2021/11/28/Advanced-Network-Technology/"/>
    <url>/2021/11/28/Advanced-Network-Technology/</url>
    
    <content type="html"><![CDATA[<p>RFC官网：<a href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a></p><h2 id="Chapter-3-Underlying-Technology"><a href="#Chapter-3-Underlying-Technology" class="headerlink" title="Chapter 3  Underlying Technology"></a>Chapter 3  Underlying Technology</h2><h3 id="1、Project-IEEE-802"><a href="#1、Project-IEEE-802" class="headerlink" title="1、Project IEEE  802"></a>1、Project IEEE  802</h3><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120160927552.png" alt="image-20211120160927552"></p><h3 id="2、以太网帧"><a href="#2、以太网帧" class="headerlink" title="2、以太网帧"></a>2、以太网帧</h3><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120161514871.png" alt="image-20211120161514871"></p><p>前同步码：56bit交替出现的1和0；用来提醒系统有帧到来，并且使它与输入定时同步</p><p>SFD：帧首定界符，标志（10101011）</p><p>限制以太网帧最大长度有两个原因：</p><ul><li>最初设计以太网时，内存非常昂贵，限制最大长度有助于减少缓存大小。</li><li>最大长度的限制可以防止一个站垄断了共享媒体，组织其他需要发送数据的站发送。</li></ul><h3 id="3、MAC地址"><a href="#3、MAC地址" class="headerlink" title="3、MAC地址"></a>3、MAC地址</h3><p>格式：6字节，每个字节用冒号隔开</p><p>单播：目的地址第一个字节最低位是0</p><p>多播：目的地址第一个字节最低位是1</p><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120162743499.png" alt="image-20211120162743499"></p><p><strong>注意</strong>：帧在物理线路上的传输格式</p><p><strong>例题3.2</strong>：描绘出地址 <code>47:20:1B:2E:08:EE</code> 是如何发送到线路上去的。</p><p><strong>解：</strong> 该地址是从左到右，逐字节地发送，而对每个字节来说又是从右到左，逐位发送，如下所示：</p><pre><code>**``&lt;- 1110 0010 0000 0100 1101 1000 0111 0100 0001 0000 0111 0111``**        74 02 B1 E2 80 EE</code></pre><p>也就是小端模式（<code>Little Endian</code>）</p><h3 id="4、标准以太网（802-3）"><a href="#4、标准以太网（802-3）" class="headerlink" title="4、标准以太网（802.3）"></a>4、标准以太网（802.3）</h3><p>数据率：10Mbps</p><p>接入方法：CSMA/CD</p><p>最大帧长：1518字节</p><p>最小帧长：</p><ul><li><p>帧传输时间 $T_r$ 必须是最大传播时间 $T_p$ 的两倍</p></li><li><p>长度：64字节( $2\times25.6\mu s\times 10Mbps=64Bytes$ )</p></li></ul><p>CSMA/CD处理流程：</p><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120164553112.png" alt="image-20211120164553112"></p><p>二进制指数退避法</p><h3 id="5、快速以太网（802-3u）"><a href="#5、快速以太网（802-3u）" class="headerlink" title="5、快速以太网（802.3u）"></a>5、快速以太网（802.3u）</h3><ul><li>采用星形拓扑</li><li>全双工和半双工通信方式下都保留CSMA/CD</li><li>数据率为100Mbps</li></ul><h3 id="6、吉比特以太网（802-3z）"><a href="#6、吉比特以太网（802-3z）" class="headerlink" title="6、吉比特以太网（802.3z）"></a>6、吉比特以太网（802.3z）</h3><ul><li>数据率1Gbps</li><li>几乎都按全双工方式通信</li></ul><h3 id="7、10G以太网（802-3ae）"><a href="#7、10G以太网（802-3ae）" class="headerlink" title="7、10G以太网（802.3ae）"></a>7、10G以太网（802.3ae）</h3><ul><li>数据率10Gbps</li></ul><h3 id="8、无线局域网（802-11）"><a href="#8、无线局域网（802-11）" class="headerlink" title="8、无线局域网（802.11）"></a>8、无线局域网（802.11）</h3><ul><li>BSS</li><li>ESS</li><li>AP</li><li>RTS</li><li>CTS</li><li>DIFS</li><li>SIFS</li><li>NAV</li><li>编址</li><li>无线局域网不能应用CSMA/CD的原因<ul><li>一个站若要进行碰撞检测则需要同时发送数据和接受碰撞信号，这意味着费用增加和带宽需求增加。</li><li>隐蔽站导致碰撞无法被检测到</li><li>战与站之间距离过远导致信号衰减</li></ul></li><li>隐蔽站<br><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120191541111.png" alt="image-20211120191541111"></li><li>暴露站</li></ul><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120191606775.png" alt="image-20211120191606775"></p><h3 id="9、P2P广域网"><a href="#9、P2P广域网" class="headerlink" title="9、P2P广域网"></a>9、P2P广域网</h3><ul><li>PPP协议<ul><li>帧格式</li><li>LCP（Link Control Protocol）负责建立、维护和终止链路</li><li>NCP（Network Control Protocol）可以用于携带IP分组</li><li>PPPoE（PPP over Ethernet）</li></ul></li></ul><h3 id="10、数据链路层设备"><a href="#10、数据链路层设备" class="headerlink" title="10、数据链路层设备"></a>10、数据链路层设备</h3><ul><li>集线器（Hub）</li><li>交换机（Switch）</li></ul><h2 id="Chapter-4-Introduction-to-Network-Layer"><a href="#Chapter-4-Introduction-to-Network-Layer" class="headerlink" title="Chapter 4 Introduction to Network Layer"></a>Chapter 4 Introduction to Network Layer</h2><h3 id="1、网络层数据交换"><a href="#1、网络层数据交换" class="headerlink" title="1、网络层数据交换"></a>1、网络层数据交换</h3><ul><li>电路交换</li><li>分组交换<ul><li>无连接服务</li><li>面向连接服务<ul><li>虚电路</li></ul></li></ul></li></ul><h3 id="2、网络层服务"><a href="#2、网络层服务" class="headerlink" title="2、网络层服务"></a>2、网络层服务</h3><ul><li>源计算机服务<ul><li>上层数据分组</li><li>查找下一跳逻辑地址</li><li>查找下一跳物理地址</li><li>数据报分片</li></ul></li><li>路由器服务<ul><li>查找下一跳逻辑地址</li><li>查找下一跳物理地址</li><li>数据报分片</li></ul></li><li>目的计算机服务<ul><li>重组数据报分片</li><li>数据交付</li><li>数据报分片有效性检测</li></ul></li></ul><h3 id="3、网络层功能"><a href="#3、网络层功能" class="headerlink" title="3、网络层功能"></a>3、网络层功能</h3><ul><li>差错控制：ICMP</li><li>流量控制</li><li>拥塞控制</li></ul><h2 id="Chapter-5-IPv4-Address"><a href="#Chapter-5-IPv4-Address" class="headerlink" title="Chapter 5 IPv4 Address"></a>Chapter 5 IPv4 Address</h2><h3 id="1、特殊地址块"><a href="#1、特殊地址块" class="headerlink" title="1、特殊地址块"></a>1、特殊地址块</h3><ul><li>全0地址：通常用在主机不知道自己的ip地址，且为了找出自己的地址，向DHCP服务器发送全1广播地址时使用。</li></ul><h3 id="2、NAT"><a href="#2、NAT" class="headerlink" title="2、NAT"></a>2、NAT</h3><ul><li>PAT（Port Address Translation）端口多路复用</li><li>NAPT（Network Address Port Tranlation）网络地址端口转换</li><li><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120210300640.png" alt="image-20211120210300640"></li></ul><h3 id="3、Question"><a href="#3、Question" class="headerlink" title="3、Question"></a>3、Question</h3><ul><li><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120203355171.png" alt="image-20211120203355171"></p></li><li><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120203410466.png" alt="image-20211120203410466"></p></li><li><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120204509949.png" alt="image-20211120204509949"></p></li><li><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120204525337.png" alt="image-20211120204525337"></p></li></ul><h2 id="Chapter-6-Delivery-and-Forwarding-of-IP-Packets"><a href="#Chapter-6-Delivery-and-Forwarding-of-IP-Packets" class="headerlink" title="Chapter 6 Delivery and Forwarding of IP Packets"></a>Chapter 6 Delivery and Forwarding of IP Packets</h2><h3 id="1、交付（Delivery）"><a href="#1、交付（Delivery）" class="headerlink" title="1、交付（Delivery）"></a>1、交付（Delivery）</h3><p>​    对分组的物理传送</p><h3 id="2、转发（Forwarding）"><a href="#2、转发（Forwarding）" class="headerlink" title="2、转发（Forwarding）"></a>2、转发（Forwarding）</h3><p>​    查找路由表找到到达目的分组的路径</p><h3 id="3、路由选择（Routing）"><a href="#3、路由选择（Routing）" class="headerlink" title="3、路由选择（Routing）"></a>3、路由选择（Routing）</h3><p>​    找寻并维护所有可能目的地的路径</p><h3 id="4、Question"><a href="#4、Question" class="headerlink" title="4、Question"></a>4、Question</h3><p>​    <img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211120212523503.png" alt="image-20211120212523503"></p><h2 id="Chapter-7-Internet-Protocol-Version-4（IPv4）"><a href="#Chapter-7-Internet-Protocol-Version-4（IPv4）" class="headerlink" title="Chapter 7 Internet Protocol Version 4（IPv4）"></a>Chapter 7 Internet Protocol Version 4（IPv4）</h2><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211121104446115.png" alt="image-20211121104446115"></p><h3 id="1、IP数据报格式"><a href="#1、IP数据报格式" class="headerlink" title="1、IP数据报格式"></a>1、IP数据报格式</h3><ul><li>分片</li><li>选项字段<ul><li>无操作选项</li><li>选项结束选项</li><li>记录路由选项：选项字段中记录源数据报经过路由器的出口地址</li><li>严格源路由选项：指定源数据报经过路由器的入口IP地址</li><li>不严格源路由选项</li></ul></li></ul><h3 id="2、IP-over-ATM"><a href="#2、IP-over-ATM" class="headerlink" title="2、IP over ATM"></a>2、IP over ATM</h3><h2 id="Chapter-8-Address-Resolution-Protocol（ARP）"><a href="#Chapter-8-Address-Resolution-Protocol（ARP）" class="headerlink" title="Chapter 8 Address Resolution Protocol（ARP）"></a>Chapter 8 Address Resolution Protocol（ARP）</h2><h3 id="1、ARP"><a href="#1、ARP" class="headerlink" title="1、ARP"></a>1、ARP</h3><h3 id="2、ATMARP"><a href="#2、ATMARP" class="headerlink" title="2、ATMARP"></a>2、ATMARP</h3><ul><li>PVC永久虚电路</li><li>SVC交换虚电路</li><li>LIS</li><li>ARP软件包</li></ul><h2 id="Chapter-9-Internet-Control-Message-Protocol-Version4（ICMPv4）"><a href="#Chapter-9-Internet-Control-Message-Protocol-Version4（ICMPv4）" class="headerlink" title="Chapter 9 Internet Control Message Protocol Version4（ICMPv4）"></a>Chapter 9 Internet Control Message Protocol Version4（ICMPv4）</h2><p>​    网络层IPv4提供的是不可靠和无连接的数据交付（Best Effort Delivery），因此缺少差错控制和辅助机制，由此诞生了ICMPv4协议。</p><p>​    ICMP是网络层协议，但需要先封装成IP数据报才能被传递给下一层，<strong>IP数据报中协议字段是 1 表示其为ICMP报文。</strong></p><h3 id="1、ICMP报文"><a href="#1、ICMP报文" class="headerlink" title="1、ICMP报文"></a>1、ICMP报文</h3><p>​    <img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211121152840865.png" alt="image-20211121152840865"></p><ul><li><p><strong>差错报告报文</strong></p><p>​    所有差错报文都包含一个数据部分，其包括原始数据报的IP首部 + 该数据报数据部分前8个字节。加上原始数据报首部是为了向接收差错报文的原始信源给出关于数据报本身的信息。</p><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211121152653458.png" alt="image-20211121152653458"></p><ul><li><p>终点不可达</p><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211121153145446.png" alt="image-20211121153145446"></p><p>代码2和3只能由目的主机产生，其余只能由路由器产生。</p></li><li><p>源点抑制</p><ul><li>目的主机计时器</li></ul></li><li><p>超时</p></li><li><p>参数问题</p></li><li><p>改变路由</p><p>​    改变主机路由</p></li></ul></li><li><p><strong>查询报文</strong> </p><ul><li>回送请求（echo-request）</li><li>回送回答（echo-reply）</li><li>时间戳请求（timestamp-request）</li><li>时间戳回答（timestamp-reply）</li></ul></li><li><p><strong>ping</strong></p></li><li><p><strong>traceroute</strong></p></li></ul><h2 id="Chapter-10-Mobile-IP"><a href="#Chapter-10-Mobile-IP" class="headerlink" title="Chapter 10 Mobile IP"></a>Chapter 10 Mobile IP</h2><h3 id="1、编址"><a href="#1、编址" class="headerlink" title="1、编址"></a>1、编址</h3><ul><li>两个地址<ul><li>归属地址</li><li>转交地址</li></ul></li><li>两个代理<ul><li>归属代理—归属网络上的路由器</li><li>外地代理—外地网络上的路由器</li></ul></li><li>移动主机与远程主机通信三个阶段<ul><li>代理发现（使用ICMP路由器通告报文）<ul><li>发现归属代理</li><li>发现外地代理</li></ul></li><li>登记<ul><li>登记报文使用UDP，代理使用434端口，主机使用一个临时端口。</li></ul></li><li>数据传送<ul><li>远程主机到归属代理</li><li>归属代理到外地代理</li><li>外地代理到移动主机</li><li>移动主机到远程主机</li></ul></li></ul></li></ul><h3 id="2、移动IP的低效率问题"><a href="#2、移动IP的低效率问题" class="headerlink" title="2、移动IP的低效率问题"></a>2、移动IP的低效率问题</h3><ul><li>两次穿越（2X）</li><li>三角路由选择</li></ul><h2 id="Chapter-11-Unicast-Routing-Protocols"><a href="#Chapter-11-Unicast-Routing-Protocols" class="headerlink" title="Chapter 11 Unicast Routing Protocols"></a>Chapter 11 Unicast Routing Protocols</h2><h3 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h3><ul><li>路由选择协议<ul><li>域内路由<ul><li>距离向量—RIP（基于UDP</li><li>链路状态—OSPF（基于IP</li></ul></li><li>域间路由<ul><li>路径向量—BGO（基于TCP</li></ul></li></ul></li></ul><h3 id="2、路由算法"><a href="#2、路由算法" class="headerlink" title="2、路由算法"></a>2、路由算法</h3><ul><li><p>距离向量路由选择</p><ul><li><p>Bellman-Ford算法</p><script type="math/tex; mode=display">D_{ij}=minimum\{(c_{i1}+D_{1j}),(c_{i2}+D_{2j}),...,(c_{iN}+D_{Nj})\}</script><p>$D_{ij}$ 表示 $i$ 和 $j$ 之间的最短距离</p><p>$c_{ij}$ 表示  $i$ 和 $j$ 之间的代价</p><p>$N$ 表示结点数</p></li><li><p>RIP（Routing Information Protocol）路由信息协议</p><ul><li>报文格式</li><li>请求和响应</li><li>计时器Timer<ol><li>定期计时器</li><li>截止期定时器</li><li>无用信息收集计时器</li></ol></li></ul></li></ul></li><li><p>链路状态路由选择</p><ul><li><p>构造路由表</p><ul><li>每个结点创建一个链路状态分组Link State Packet</li><li>洪泛向其他结点散发LSP</li><li>为每个节点形成一个最短路径树（ $Dijkstra$ 算法）</li><li>基于路径树计算路由表</li></ul></li><li><p>OSPF（Open Shortest Path Firs）协议</p><ul><li>问候分组（Hello Packet）</li><li>数据库描述分组（Database Description Packet）</li><li>链路状态请求分组（LInk State Request Packet）</li><li>链路状态更新分组</li><li>链路状态确认分组</li></ul><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211122211416927.png" alt="image-20211122211416927"></p><p><img src="C:\Users\KingBob\AppData\Roaming\Typora\typora-user-images\image-20211122211437365.png" alt="image-20211122211437365"></p></li></ul></li><li><p>路径向量路由选择（Path Vector Routing）</p><ul><li>BGP（Border Gateway Protocol）</li></ul></li></ul><h2 id="Chapter-12-Multicasting-And-Multicast-Routing-Protocols"><a href="#Chapter-12-Multicasting-And-Multicast-Routing-Protocols" class="headerlink" title="Chapter 12 Multicasting And Multicast Routing Protocols"></a>Chapter 12 Multicasting And Multicast Routing Protocols</h2><h3 id="1、多播地址（IPv4）"><a href="#1、多播地址（IPv4）" class="headerlink" title="1、多播地址（IPv4）"></a>1、多播地址（IPv4）</h3><ul><li>本地网络控制地址块</li><li>网际互连控制地址块</li></ul><h3 id="2、数据链路层多播分组"><a href="#2、数据链路层多播分组" class="headerlink" title="2、数据链路层多播分组"></a>2、数据链路层多播分组</h3><ul><li>支持多播的网络（大部分局域网<ul><li>MAC地址转换</li></ul></li><li>不支持多播的网络（大部分广域网<ul><li>隧道技术</li></ul></li></ul><h3 id="3、IGMP（Internet-Group-Management-Protocol）网际组管理协议"><a href="#3、IGMP（Internet-Group-Management-Protocol）网际组管理协议" class="headerlink" title="3、IGMP（Internet Group Management Protocol）网际组管理协议"></a>3、IGMP（Internet Group Management Protocol）网际组管理协议</h3><ul><li>IGMP报文<ul><li>成员关系查询报文</li><li>成员关系报告报文</li><li></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法导论实验一</title>
    <link href="/2021/11/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/2021/11/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="实验一-用分治法求解数组的中位数和最大子集"><a href="#实验一-用分治法求解数组的中位数和最大子集" class="headerlink" title="实验一 用分治法求解数组的中位数和最大子集"></a>实验一 用分治法求解数组的中位数和最大子集</h1><h2 id="Pro1：Median-of-Two-Sorted-Arrays"><a href="#Pro1：Median-of-Two-Sorted-Arrays" class="headerlink" title="Pro1：Median of Two Sorted Arrays"></a><strong>Pro1：Median of Two Sorted Arrays</strong></h2><p><strong>There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the</strong><br><strong>median of the two sorted arrays. The overall run time complexity should be O(log</strong><br><strong>(m+n)).</strong></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a><strong>算法思路</strong></h3><p>因为两个有序数组长度已知，所以很容易能够得到中位数的位置，但是需要分奇偶两种情况，如果两个数组长度和是奇数则中位数位置是 $(m+n+1)/2$ ，否则是第 $(m+n)/2$ 个元素和第 $(m+n)/2+1$ 个元素的平均数。所以原问题可以转化成求两个有序数组的第 $k$ 个元素。</p><p>既然要找数组 $nums1$ 和 $nums2$ 合并后的第 $k$ 个元素，可以先比较 $nums1[k/2-1]$ 和 $nums2[k/2-1]$ 的大小，因为比这两个元素小的元素个数最多为 $k/2-1+k/2-1 = k-2$ 个， 因此找到 $nums1[k/2-1]$ 和 $nums2[k/2-1]$ 中的最小值，则可以排除掉 $k/2$ 个元素；此时，将排除掉 $k/2$ 个元素的数组剩余部分作为一个新数组和未排除元素的数组继续比较，并且 $k$ 应当减小，这就把原问题分解成一个规模更小的问题，且分解后的问题与原问题类似，且可以独立求解，与常规的分治法不同，这里的不断分解的子问题最终不需要合并（尾递归），最终的子问题的解就是原问题的解。</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a><strong>算法设计</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1,<span class="hljs-keyword">int</span> left1,<span class="hljs-keyword">int</span> right1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> left2, <span class="hljs-keyword">int</span> right2, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> len1 = right1 - left1 + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> len2 = right2 - left2 + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (len1 &gt; len2) <span class="hljs-comment">//保证nums1的长度总是比nums2的长度短，方便统一讨论</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">findKth</span>(nums2, left2, right2, nums1, left1, right1, k);<br>&#125;<br><br><span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>) <span class="hljs-comment">//如果nums1的长度为0，那么返回nums2中的“第k个”元素</span><br>&#123;<br><span class="hljs-keyword">return</span> nums2[left2 + k - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果k=1的话，直接返回当前两个数组中的最小值</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[left1], nums2[left2]);<br>&#125;<br><br><span class="hljs-comment">//找到数组中k/2-1的位置，但因为k/2可能超过nums1或nums2的长度,</span><br><span class="hljs-comment">//所以当k/2大于数组长度时，应当直接取数组的剩余部分判断</span><br><span class="hljs-keyword">int</span> i = left1 + <span class="hljs-built_in">min</span>(len1, k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; <br><br><span class="hljs-keyword">int</span> j = left2 + <span class="hljs-built_in">min</span>(len2, k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; <br><span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j])<br>&#123;<br><span class="hljs-comment">//最后k需要减去删除的元素个数</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">findKth</span>(nums1, left1, right1, nums2, j + <span class="hljs-number">1</span>, right2, k - (j - left2 + <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">findKth</span>(nums1, i + <span class="hljs-number">1</span>, right1, nums2, left2, right2, k - (i - left1 + <span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br><span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">findKth</span>(nums1, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in">findKth</span>(nums1, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, (m + n) / <span class="hljs-number">2</span> ) + <span class="hljs-built_in">findKth</span>(nums1, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, (m + n) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a><strong>算法复杂度分析</strong></h3><p>主函数的复杂度取决于 $findKth$ 函数的复杂度，由于每次分解问题都会减小 $k/2$ 个元素的搜索，也就是减小问题总规模的一半，所以算法的递推式可以写成：</p><script type="math/tex; mode=display">T(n)=T(n/2)+\Theta(1)</script><p>所以时间复杂度是 $T(n)=O(logn)=O(log(m+n))$ 。</p><h2 id="Pro2：Maximum-Subarray"><a href="#Pro2：Maximum-Subarray" class="headerlink" title="Pro2：Maximum Subarray"></a><strong>Pro2：Maximum Subarray</strong></h2><p><strong>Find the contiguous subarray within an array (containing at least one number) which</strong><br><strong>has the largest sum.</strong><br><strong>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],</strong><br><strong>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</strong></p><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a><strong>算法思路</strong></h3><p>若使用分治法处理此题，我们可以将问题分为两个子问题，将数组 $A[low…high]$ 分为两部分，那么具有最大和的子数组只具有三种情况：</p><ul><li>最大和子数组位于数组左半部分 $A[low…mid]$</li><li>最大和子数组位于数组左半部分 $A[mid+1…high]$</li><li>最大和子数组横跨数组的两个部分 </li></ul><p>最后所求的具有最大和子数组一定是三种情况中取得和最大者，而针对前两种情况，我能可以递归的求解，这两个子问题显然具有原问题的性质与结构，符合分治法策略。</p><h3 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a><strong>算法设计</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCrossMaxCrossingSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high,<span class="hljs-keyword">int</span>&amp; left_pos,<span class="hljs-keyword">int</span>&amp; right_pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,left_sum=INT_MIN,right_sum=INT_MIN,mid=low+(high-low)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> i = mid;<br><span class="hljs-keyword">while</span> (i &gt;= low) <span class="hljs-comment">//找到从mid开始往左的最大子数组和并记录左位置</span><br>&#123;<br>sum += nums[i];<br><span class="hljs-keyword">if</span> (sum &gt; left_sum)<br>&#123;<br>left_sum = sum;<br>left_pos = i;<br>&#125;<br>i--;<br>&#125;<br>sum = <span class="hljs-number">0</span>;<br>i = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= high) <span class="hljs-comment">//找到从mid+1开始往右的最大子数组和并记录右位置</span><br>&#123;<br>sum += nums[i];<br><span class="hljs-keyword">if</span> (sum &gt; right_sum)<br>&#123;<br>right_sum = sum;<br>right_pos = i;<br>&#125;<br>i++;<br>&#125;<br>sum = left_sum + right_sum;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span>&amp; left_pos, <span class="hljs-keyword">int</span>&amp; right_pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (low == high)<br>&#123;<br><span class="hljs-keyword">return</span> nums[low];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;   <span class="hljs-comment">//分别找到数组左半部分最大子数组和、数组右半部分最大子数组和、</span><br><span class="hljs-comment">//横跨数组两个部分的最大子数组和，并返回三者最大值</span><br><span class="hljs-keyword">int</span> m1 = <span class="hljs-built_in">findMaxSubArray</span>(nums, low, mid,left_pos,right_pos);<br><span class="hljs-keyword">int</span> m2 = <span class="hljs-built_in">findMaxSubArray</span>(nums, mid + <span class="hljs-number">1</span>, high, left_pos, right_pos);<br><span class="hljs-keyword">int</span> m3 = <span class="hljs-built_in">findCrossMaxCrossingSubArray</span>(nums, low, high, left_pos, right_pos);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(m1, <span class="hljs-built_in">max</span>(m2, m3));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> left_pos = <span class="hljs-number">0</span>, right_pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>ret = <span class="hljs-built_in">findMaxSubArray</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, left_pos, right_pos);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left_pos;i &lt;= right_pos;++i)<br>&#123;<br>cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;MaxSum is &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法复杂度分析-1"><a href="#算法复杂度分析-1" class="headerlink" title="算法复杂度分析"></a><strong>算法复杂度分析</strong></h3><p>原问题被分为三个子问题，因此只需要分析函数 $findCrossMaxCrossingSubArray$ 的复杂度即可，显然该函数遍历数组某一部分，时间复杂度为 $O(n)$ ，因此该算法递归式为：</p><script type="math/tex; mode=display">T(n)=2T(n/2)+O(n)</script><p>根据 $Master$ 方法可知，算法复杂度 $T(n)=\Theta(nlogn)$ 。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/28/hello-world/"/>
    <url>/2021/11/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
